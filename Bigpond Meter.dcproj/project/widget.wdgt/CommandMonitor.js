/* 
 This file was generated by Dashcode.  
 You may edit this file to customize your widget or web page 
 according to the license.txt file included in the project.
 */

//
// Class: CommandMonitor
// Base class for monitors that process the output of an external command.
// Takes care of the timers and output handlers so subclasses can just
// deal with the data as it comes in.
//

//
// CommandMonitor constructor
// Sets up some default values you can change in your subclass
//
// timeOut: If no output is received for timeOut seconds, watchdog is called
// restartAfter: Re-launch external command after this long if it exits
//
function CommandMonitor()
{
    this.timeOut = 300;
    this.restartAfter = 60;
}

//
// Method: start()
// Public interface to start your command monitor
//
CommandMonitor.prototype.start = function ()
{
    document.getElementById("ind").style.opacity=1;
    if (this.commandLine != null) {
        if (this.systemCommand != null) {
            alert("Warning: attempt to re-enter command");
            this.stop();
        }

        var self = this;
        var onFinished = function (command) { self.finishedHandler(command); };
        var onOutput = function (output) { self.outputHandler(output); };

        this.startWatchdogTimer();
        this.systemCommand = widget.system(this.commandLine, onFinished);
       
        this.systemCommand.onreadoutput = onOutput;
    }
}

//
// Method: stop()
// Public interface to stop your monitor
//
CommandMonitor.prototype.stop = function ()
{
    this.stopWatchdogTimer();

    if (this.startTimer != null) {
        clearTimeout(this.startTimer);
        delete this.startTimer;
    }

    if (this.systemCommand != null) {
        this.systemCommand.cancel();
        delete this.systemCommand;
    }
}

//
// Method: cancel()
// Public interface to cancel current command.
// It will be re-started automatically.
//
CommandMonitor.prototype.cancel = function ()
{
    this.stop();
    this.startAfterInterval();
}

//
// Method: processLine(line)
// You must override this method in your subclass.  It will be called
// once for each line your external command outputs.  This is where you
// do all your work.
//
// line: A single line of output from the external command
//
CommandMonitor.prototype.processLine = function (line)
{
    // alert("Virtual processLine: " + line);
}

//
// The rest of the methods in this class are not meant for public use
//

CommandMonitor.prototype.startAfterInterval = function ()
{
    if (this.restartAfter != null) {
        if (this.startTimer != null) {
            clearTimeout(this.startTimer);
        }

        var self = this;
        this.startTimer = setTimeout(function () {
            delete self.startInterval;
            self.start();
        }, this.restartAfter * 1000);
    }
}

CommandMonitor.prototype.startWatchdogTimer = function ()
{
    
    this.stopWatchdogTimer();

    var self = this;
    this.watchdogTimer = setTimeout(function () { self.watchdogTimeout(); }, this.timeOut * 1000);
}

CommandMonitor.prototype.stopWatchdogTimer = function ()
{
    if (this.watchdogTimer != null) {
        clearTimeout(this.watchdogTimer);
        delete this.watchdogTimer;
    }
}

CommandMonitor.prototype.watchdogTimeout = function ()
{
    alert("watchdog timeout");
    if(this.errorCallback!=null){this.errorCallback(5);}
    delete this.watchdogTimer;
    this.cancel();
}

CommandMonitor.prototype.outputHandler = function (output)
{
    this.stopWatchdogTimer();
    this.processLines(output);
    this.startWatchdogTimer();
}

CommandMonitor.prototype.processLines = function (lines)
{
    if (lines != null && lines.length > 0) {
        // Normalize line endings
        lines = lines.replace(/(\x0d\x0a)+/g, "\x0a");

        var match;
        var linePattern = /^.+$/mg;
        var lineid=0;
        var total=0;
        var used=0;
        while ((match = linePattern.exec(lines)) != null) {
            var line = match[0];
            
            /*
            
            USED
            TOTAL
            PERCENT
            BILLNOW
            BILLPERCENT
            
            */
    // Take off leading and trailing spaces
            line = line.replace(/^\s+/, "");
            line = line.replace(/\s+$/, "");
        
        if(lineid==2)
        {
            var usagepercent = parseInt(line);
            // alert("disk io: " + mbps + ", load: " + load);
            if (this.loadCallback != null) {
                this.loadCallback(usagepercent);
            }
          
        }
        else if(lineid==0)
        {
        if(line=="ERROR")
            {
                if(this.errorCallback!=null){this.errorCallback(1);}
                return;
            }
            else if(line=="Account Locked for 20 mins")
            {
                 if(this.errorCallback!=null){this.errorCallback(10);}
                return;

            }
               else if(line=="Wrong Password")
            {
                 if(this.errorCallback!=null){this.errorCallback(11);}
                return;

            }
            else if(line=="Error code")
            {
                if(this.errorCallback!=null){this.errorCallback(56);}
                return;
            }
            else if(line=="No Data")
            {
                if(this.errorCallback!=null){this.errorCallback(98);}
                return;
            }
               else if(line=="Empty Reply")
            {
                if(this.errorCallback!=null){this.errorCallback(67);}
                return;
            }
            else if(line=="No Response")
            {
                if(this.errorCallback!=null){this.errorCallback(99);}
                return;
            }
            else if(line=="Please Login")
            {
                 if(this.errorCallback!=null){this.errorCallback(33);}
                return;
            }
            else if(line=="Wrong Response")
            {
               if(this.errorCallback!=null){this.errorCallback(89);}
                return;
            
            }
            else if(line=="Latin Response")
            {
               if(this.errorCallback!=null){this.errorCallback(88);}
                return;
            
            }
            else if(line=="Could Not Connect")
            {
                   if(this.errorCallback!=null){this.errorCallback(14);}
                return;
            }
            else if(line.length>=3)
            {
                if(line[0]=="E" && line[1]=="R" && line[2]=="R"){
                specmsg="Error: "+line.substr(3);
                document.getElementById("titletxt").style.color="#444";
                document.getElementById("etxt").style.top="12px";
                document.getElementById("etxt").style.color="white";
                if(this.errorCallback!=null){this.errorCallback(23);}
                return;
                }
            
            }
            used=parseInt(line);
            if (this.usedCallback != null) {
            
                this.usedCallback(used);
            }
        }
        else if(lineid==1){
        total=parseInt(line);
       
        
         if (this.freeCallback != null) {
                this.freeCallback(total-used);
            }
            
            
        }
        else if(lineid==4)
        {
        var load = parseInt(line);
          if (this.ioCallback != null) {
                this.ioCallback(load);
            }
            if(this.errorCallback!=null){this.errorCallback(9);}
            
        }
        else if(lineid==5)
        {
          if (this.jsCallback != null) {
                this.jsCallback(line);
            }
            if(this.errorCallback!=null){this.errorCallback(9);}
            
        }
    lineid=lineid+1;
    
    
        }
    }
}

/*
 // Look for a line of numbers
    var match;
    if ((match = line.match(/^(\s*[\d\.]+)+$/)) != null) {
        var n = match[0].split(/\s+/);

        if (n.length > 0 && n.length % 3 == 0) {
            // Add up all the MB/s numbers
            var mbps = 0.0;
            for (var i = 2; i < n.length - 3; i += 3) {
                mbps += parseFloat(n[i]);
            }

            // Grab the inverse of the CPU idle time and call it load
            */
CommandMonitor.prototype.finishedHandler = function (command)
{
    // alert("finished");
    this.stopWatchdogTimer();
    this.processLines(command.outputString);
    delete this.systemCommand;
    this.startAfterInterval();
}

//
// Class: IOStatMonitor
// CommandMonitor subclass that processes the output of "iostat".
// Uses two callbacks to return the load average and device I/O statistics
//

function IOStatMonitor (frequency, ioCallback, loadCallback,freeCallback,usedCallback,errorCallback,jsCallback) {

    this.commandLine = "";
    this.ioCallback = ioCallback;
    
    this.jsCallback = jsCallback;
    this.loadCallback = loadCallback;
    this.freeCallback = freeCallback;
    this.usedCallback = usedCallback;
    this.errorCallback = errorCallback;
}

IOStatMonitor.prototype = new CommandMonitor();


